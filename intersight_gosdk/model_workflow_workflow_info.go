/*
Cisco Intersight

Cisco Intersight is a management platform delivered as a service with embedded analytics for your Cisco and 3rd party IT infrastructure. This platform offers an intelligent level of management that enables IT organizations to analyze, simplify, and automate their environments in more advanced ways than the prior generations of tools. Cisco Intersight provides an integrated and intuitive management experience for resources in the traditional data center as well as at the edge. With flexible deployment options to address complex security needs, getting started with Intersight is quick and easy. Cisco Intersight has deep integration with Cisco UCS and HyperFlex systems allowing for remote deployment, configuration, and ongoing maintenance. The model-based deployment works for a single system in a remote location or hundreds of systems in a data center and enables rapid, standardized configuration and deployment. It also streamlines maintaining those systems whether you are working with small or very large configurations. The Intersight OpenAPI document defines the complete set of properties that are returned in the HTTP response. From that perspective, a client can expect that no additional properties are returned, unless these properties are explicitly defined in the OpenAPI document. However, when a client uses an older version of the Intersight OpenAPI document, the server may send additional properties because the software is more recent than the client. In that case, the client may receive properties that it does not know about. Some generated SDKs perform a strict validation of the HTTP response body against the OpenAPI document.

API version: 1.0.11-18775
Contact: intersight@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package intersight

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"
)

// checks if the WorkflowWorkflowInfo type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &WorkflowWorkflowInfo{}

// WorkflowWorkflowInfo Contains information for a workflow which is an execution instance of the workflow definition given in the relationship. The workflow definition will provide the schema of the inputs taken to start the workflow execution and the schema of the outputs generated at the end of successful workflow execution. The sequence of tasks to be executed is also provided in the workflow definition. For a workflow to successfully start execution the following properties must be provided- Name, AssociatedObject that carries the relationship to Organization under which the workflow must be executed, WorkflowDefinition, and Inputs with all the required data in order to start workflow execution.
type WorkflowWorkflowInfo struct {
	MoBaseMo
	// The fully-qualified name of the instantiated, concrete type. This property is used as a discriminator to identify the type of the payload when marshaling and unmarshaling data.
	ClassId string `json:"ClassId"`
	// The fully-qualified name of the instantiated, concrete type. The value should be the same as the 'ClassId' property.
	ObjectType string `json:"ObjectType"`
	// The action of the workflow such as start, cancel, retry, pause. * `None` - No action is set, this is the default value for action field. * `Create` - Create a new instance of the workflow but it does not start the execution of the workflow. Use the Start action to start execution of the workflow. * `Start` - Start a new execution of the workflow. * `Pause` - Pause the workflow, this can only be issued on workflows that are in running state. A workflow can be paused for a maximum of 180 days, after 180 days the workflow will be terminated by the system. * `Resume` - Resume the workflow which was previously paused through pause action on the workflow. * `Rerun` - Rerun the workflow that has previously reached a failed state. The workflow is run from the beginning using inputs from previous execution. Completed and currently running workflows cannot be rerun. Workflows do not have to be marked for retry to use this action. * `Retry` - This action has been deprecated. Please use RetryFailed, Rerun or RetryFromTask action. Retry the workflow that has previously reached a final state and has the retryable property set to true. A running or waiting workflow cannot be retried. If the property retryFromTaskName is also passed along with this action, the workflow will be started from that specific task, otherwise the workflow will be restarted from the first task.  The task name in retryFromTaskName must be one of the tasks that completed or failed in the previous run. It is not possible to retry a workflow from a task which wasn't run in the previous iteration. * `RetryFailed` - Retry the workflow that has failed. A running or waiting workflow or a workflow that completed successfully cannot be retried. Only the tasks that failed in the previous run will be retried and the rest of workflow will be run. This action does not restart the workflow and also does not support retrying from a specific task. * `RetryFromTask` - Retry the workflow that has previously reached a failed state and has the retryable property set to true. A running or waiting workflow cannot be retried. RetryFromTaskName must be passed along with this action, and the workflow will be started from that specific task. The task name in RetryFromTaskName must be one of the tasks that was executed in the previous attempt. It is not possible to retry a workflow from a task that wasn't run in the previous execution attempt. * `Cancel` - Cancel the workflow that is in running or waiting state.
	Action *string `json:"Action,omitempty"`
	// The time when the workflow info will be removed from the database. When WorkflowInfo is created, cleanup time will be set to 181 days. As the workflow progresses through different states the cleanup time can be updated. A cleanup time of 0 means the workflow is not scheduled for cleanup. An active workflow that continues to schedule & run tasks can run for any amount of time and there is no upper bound for such workflows. Workflows that are not actively running, say in Paused or Waiting states will be removed after 181 days.
	CleanupTime *time.Time `json:"CleanupTime,omitempty"`
	// The email address of the user who started this workflow. In the case of LDAP users, this field can hold either a username or an email.
	Email *string `json:"Email,omitempty"`
	// The time when the workflow reached a final state.
	EndTime *time.Time `json:"EndTime,omitempty"`
	// The duration in hours after which the workflow info for failed, terminated or timed out workflow will be removed from database. The minimum is 1 hour, maximum is 365 days and default is 90 days.
	FailedWorkflowCleanupDuration *int64 `json:"FailedWorkflowCleanupDuration,omitempty"`
	// All the given inputs for the workflow. The schema for the inputs is defined in the InputDefinition section of the WorkflowDefinition. The InputDefinition will provide a list of input fields to be accepted, the associated datatype of the inputs and any additional constraints on the inputs. For more information please refer to InputDefinition property in the the the WorkflowDefinition resource. The inputs for a workflow are provided as a collection of key-value pairs, where key is the name of the input and value is any valid JSON data which conforms to the datatype of the input as specified in the InputDefinition. When the input passed into a workflow does not match the datatype or the constraints specified in the workflow definition, it will not be accepted. For example, if the InputDefinition specified that workflow must accept a string name 'key' and the value passed for key must adhere to a regex pattern. If Workflow was started with input where 'key' is not a string matching the regex pattern, an error will be generated and workflow will not start execution. During workflow definition design, the input passed into the workflow will be referred using the format 'workflow.input.<inputName>'. If the input is referred directly in a mapping it will be in the format '${workflow.input.<inputName>}' or inside a template mapping in the format '{{.global.workflow.input.<inputName>}}'.
	Input interface{} `json:"Input,omitempty"`
	// A workflow instance Id which is the unique identified for the workflow execution.
	InstId *string `json:"InstId,omitempty"`
	// Denotes that an Intersight service started this workflow as internal and hence will not be shown in Intersight User Interface. Typically these are internal system maintenance workflows which are triggered by Intersight services.
	Internal *bool `json:"Internal,omitempty"`
	// The last action that was issued on the workflow is saved in this field. * `None` - No action is set, this is the default value for action field. * `Create` - Create a new instance of the workflow but it does not start the execution of the workflow. Use the Start action to start execution of the workflow. * `Start` - Start a new execution of the workflow. * `Pause` - Pause the workflow, this can only be issued on workflows that are in running state. A workflow can be paused for a maximum of 180 days, after 180 days the workflow will be terminated by the system. * `Resume` - Resume the workflow which was previously paused through pause action on the workflow. * `Rerun` - Rerun the workflow that has previously reached a failed state. The workflow is run from the beginning using inputs from previous execution. Completed and currently running workflows cannot be rerun. Workflows do not have to be marked for retry to use this action. * `Retry` - This action has been deprecated. Please use RetryFailed, Rerun or RetryFromTask action. Retry the workflow that has previously reached a final state and has the retryable property set to true. A running or waiting workflow cannot be retried. If the property retryFromTaskName is also passed along with this action, the workflow will be started from that specific task, otherwise the workflow will be restarted from the first task.  The task name in retryFromTaskName must be one of the tasks that completed or failed in the previous run. It is not possible to retry a workflow from a task which wasn't run in the previous iteration. * `RetryFailed` - Retry the workflow that has failed. A running or waiting workflow or a workflow that completed successfully cannot be retried. Only the tasks that failed in the previous run will be retried and the rest of workflow will be run. This action does not restart the workflow and also does not support retrying from a specific task. * `RetryFromTask` - Retry the workflow that has previously reached a failed state and has the retryable property set to true. A running or waiting workflow cannot be retried. RetryFromTaskName must be passed along with this action, and the workflow will be started from that specific task. The task name in RetryFromTaskName must be one of the tasks that was executed in the previous attempt. It is not possible to retry a workflow from a task that wasn't run in the previous execution attempt. * `Cancel` - Cancel the workflow that is in running or waiting state.
	LastAction *string           `json:"LastAction,omitempty"`
	Message    []WorkflowMessage `json:"Message,omitempty"`
	// A name of the workflow execution instance.
	Name *string `json:"Name,omitempty" validate:"regexp=^[^:]{1,92}$"`
	// All the generated outputs for the workflow. The schema for the outputs are defined in the OutputDefinition section of the WorkflowDefinition. The OutputDefinition will provide a list of output fields that could be generated after workflow execution is completed and the associated datatype of the outputs. For more information please refer to OutputDefinition property in WorkflowDefinition resource. The output for the workflow is generated as a collection of key-value pairs, where key is the name of the output and value is any valid JSON data which conforms to the datatype of output as specified in the OutputDefinition. During workflow definition design, if a workflow is included as a sub-workflow inside a parent workflow then the outputs generated by the sub-workflow can be used in the workflow design. For example, if workflow was included into parent workflow as 'SubWorkflowSample1', then that output can be referred as 'SubWorkflowSample1.output.<outputName>'. In the output is referred directly in a mapping it will be in the format '${SubWorkflowSample1.output.<outputName>}' or inside a template mapping will be in the format '{{SubWorkflowSample1.output.<outputName>}}'.
	Output interface{} `json:"Output,omitempty"`
	// Denotes the reason workflow is in paused status. * `None` - Pause reason is none, which indicates there is no reason for the pause state. * `TaskWithWarning` - Pause reason indicates the workflow is in this state due to a task that has a status as completed with warnings. * `SystemMaintenance` - Pause reason indicates the workflow is in this state based on actions of system admin for maintenance.
	PauseReason *string `json:"PauseReason,omitempty"`
	// This field indicates percentage of workflow task completion based on the total number of tasks in the workflow. The total number of tasks in the workflow is calculated based on the longest path the workflow execution can take. So progress is calculated based on the percentage of tasks that completed out of the total number of tasks that could be executed. Progress is not a representation of the time taken to complete the workflow. A task is considered as completed if the task status is either \"NO_OP\" or \"COMPLETED\". If the task status is \"SKIP_TO_FAIL\", the workflow will be terminated and the progress of the workflow will be set to 100.
	Progress   *float32                               `json:"Progress,omitempty"`
	Properties NullableWorkflowWorkflowInfoProperties `json:"Properties,omitempty"`
	// This field is required when RetryFromTask action is issued for a workflow that is in a 'final' state. The workflow will be retried from the specified task. This field must specify a task name which is the unique name of the task within the workflow. The task name must be one of the tasks that were completed or failed in the previous run. It is not possible to retry a workflow from a task that wasn't run in the previous execution attempt.
	RetryFromTaskName *string `json:"RetryFromTaskName,omitempty"`
	// The source service that started the workflow execution and hence represents the owning service for this workflow.
	Src *string `json:"Src,omitempty"`
	// The time when the workflow was started for execution.
	StartTime *time.Time `json:"StartTime,omitempty"`
	// A status of the workflow (RUNNING, WAITING, COMPLETED, TIME_OUT, FAILED). The \"status\" field has been deprecated and is now replaced with the \"workflowStatus\" field.
	// Deprecated
	Status *string `json:"Status,omitempty"`
	// The duration in hours after which the workflow info for successful workflow will be removed from database. The minimum is 1 hour, maximum is 365 days and default is 90 days.
	SuccessWorkflowCleanupDuration *int64                         `json:"SuccessWorkflowCleanupDuration,omitempty"`
	TaskInfoUpdate                 NullableWorkflowTaskInfoUpdate `json:"TaskInfoUpdate,omitempty"`
	// The trace id to keep track of workflow execution.
	TraceId *string `json:"TraceId,omitempty"`
	// A type of the workflow (serverconfig, ansible_monitoring).
	Type *string `json:"Type,omitempty"`
	// Property will be set when a user action is required on the workflow. This can be because the workflow is waiting for a wait task to be updated, workflow is paused or workflow launched by a configuration object has failed and needs to be retried in order to complete successfully.
	UserActionRequired *bool `json:"UserActionRequired,omitempty"`
	// The user identifier which indicates the user that started this workflow.
	UserId *string `json:"UserId,omitempty"`
	// All the generated variables for the workflow. During workflow execution, the variables will be updated as per the variableParameters specified after each task execution.
	Variable interface{} `json:"Variable,omitempty"`
	// Denotes the reason workflow is in waiting status. * `None` - Wait reason is none, which indicates there is no reason for the waiting state. * `GatherTasks` - Wait reason is gathering tasks, which indicates the workflow is in this state in order to gather tasks. * `Duplicate` - Wait reason is duplicate, which indicates the workflow is a duplicate of current running workflow. * `RateLimit` - Wait reason is rate limit, which indicates the workflow is rate limited by account/instance level throttling threshold. * `WaitTask` - Wait reason when there are one or more wait tasks in the workflow which are yet to receive a task status update. * `PendingRetryFailed` - Wait reason when the workflow is pending a RetryFailed action. * `WaitingToStart` - Workflow is waiting to start on workflow engine.
	WaitReason  *string                     `json:"WaitReason,omitempty"`
	WorkflowCtx NullableWorkflowWorkflowCtx `json:"WorkflowCtx,omitempty"`
	// The current state of the workflow execution instance. A draft workflow execution will be in NotStarted state and when \"Start\" action is issued then the workflow will move into Waiting state until the first task of the workflow is scheduled at which time it will move into InProgress state. When execution reaches a final state it move to either Completed, Failed or Terminated state. For more details look at the description for each state. * `NotStarted` - Initially all the workflow instances are at \"NotStarted\" state. A workflow can be drafted in this state by issuing Create action. When a workflow is in this state the inputs can be updated until the workflow is started. * `InProgress` - A workflow execution moves into \"InProgress\" state when the first task of the workflow is scheduled for execution and continues to remain in that state as long as there are tasks executing or yet to be scheduled for execution. * `Waiting` - Workflow can go to waiting state due to execution of wait task present in the workflow or the workflow has not started yet either due to duplicate workflow is running or due to workflow throttling. Once Workflow engine picks up the workflow for execution, it will move to in progress state. * `Completed` - A workflow execution moves into Completed state when the execution path of the workflow has reached the Success node in the workflow design and there are no more tasks to be executed. Completed is the final state for the workflow execution instance and no further actions are allowed on this workflow instance. * `Failed` - A workflow execution moves into a Failed state when the execution path of the workflow has reached the Failed node in the workflow design and there are no more tasks to be scheduled. A Failed node can be reached when the last executed task has failed or timed out and there are no further retries available for the task. Also as per the workflow design, the last executed task did not specify an OnFailure task to be executed and hence by default, the execution will reach the Failed node. Actions like \"Rerun\", \"RetryFailed\" and \"RetryFromTask\" can be issued on failed workflow instances. Please refer to the \"Action\" description for more details. * `Terminated` - A workflow execution moves to Terminated state when user issues a \"Cancel\" action or due to internal errors caused during workflow execution. e.g. - Task input transformation has failed. Terminated is a final state of the workflow, no further action are allowed on this workflow instance. * `Canceled` - A workflow execution moves to Canceled state when a user issues a \"Cancel\" action. Cancel is not a final state, the workflow engine will issue cancel to all the running tasks and then move the workflow to the \"Terminated\" state. * `Paused` - A workflow execution moves to Paused state when user issues a \"Pause\" action. When in paused state the current running task will complete its execution but no further tasks will be scheduled until the workflow is resumed. A paused workflow is resumed when the user issues a \"Resume\" action. Paused workflows can be canceled by user.
	WorkflowStatus   *string                                      `json:"WorkflowStatus,omitempty"`
	Account          NullableIamAccountRelationship               `json:"Account,omitempty"`
	AssociatedObject NullableMoBaseMoRelationship                 `json:"AssociatedObject,omitempty"`
	Organization     NullableOrganizationOrganizationRelationship `json:"Organization,omitempty"`
	ParentTaskInfo   NullableWorkflowTaskInfoRelationship         `json:"ParentTaskInfo,omitempty"`
	Permission       NullableIamPermissionRelationship            `json:"Permission,omitempty"`
	// An array of relationships to workflowTaskInfo resources.
	TaskInfos            []WorkflowTaskInfoRelationship                 `json:"TaskInfos,omitempty"`
	WorkflowDefinition   NullableWorkflowWorkflowDefinitionRelationship `json:"WorkflowDefinition,omitempty"`
	AdditionalProperties map[string]interface{}
}

type _WorkflowWorkflowInfo WorkflowWorkflowInfo

// NewWorkflowWorkflowInfo instantiates a new WorkflowWorkflowInfo object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewWorkflowWorkflowInfo(classId string, objectType string) *WorkflowWorkflowInfo {
	this := WorkflowWorkflowInfo{}
	this.ClassId = classId
	this.ObjectType = objectType
	var action string = "None"
	this.Action = &action
	var failedWorkflowCleanupDuration int64 = 2160
	this.FailedWorkflowCleanupDuration = &failedWorkflowCleanupDuration
	var successWorkflowCleanupDuration int64 = 2160
	this.SuccessWorkflowCleanupDuration = &successWorkflowCleanupDuration
	return &this
}

// NewWorkflowWorkflowInfoWithDefaults instantiates a new WorkflowWorkflowInfo object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewWorkflowWorkflowInfoWithDefaults() *WorkflowWorkflowInfo {
	this := WorkflowWorkflowInfo{}
	var classId string = "workflow.WorkflowInfo"
	this.ClassId = classId
	var objectType string = "workflow.WorkflowInfo"
	this.ObjectType = objectType
	var action string = "None"
	this.Action = &action
	var failedWorkflowCleanupDuration int64 = 2160
	this.FailedWorkflowCleanupDuration = &failedWorkflowCleanupDuration
	var successWorkflowCleanupDuration int64 = 2160
	this.SuccessWorkflowCleanupDuration = &successWorkflowCleanupDuration
	return &this
}

// GetClassId returns the ClassId field value
func (o *WorkflowWorkflowInfo) GetClassId() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ClassId
}

// GetClassIdOk returns a tuple with the ClassId field value
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetClassIdOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ClassId, true
}

// SetClassId sets field value
func (o *WorkflowWorkflowInfo) SetClassId(v string) {
	o.ClassId = v
}

// GetDefaultClassId returns the default value "workflow.WorkflowInfo" of the ClassId field.
func (o *WorkflowWorkflowInfo) GetDefaultClassId() interface{} {
	return "workflow.WorkflowInfo"
}

// GetObjectType returns the ObjectType field value
func (o *WorkflowWorkflowInfo) GetObjectType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ObjectType
}

// GetObjectTypeOk returns a tuple with the ObjectType field value
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetObjectTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ObjectType, true
}

// SetObjectType sets field value
func (o *WorkflowWorkflowInfo) SetObjectType(v string) {
	o.ObjectType = v
}

// GetDefaultObjectType returns the default value "workflow.WorkflowInfo" of the ObjectType field.
func (o *WorkflowWorkflowInfo) GetDefaultObjectType() interface{} {
	return "workflow.WorkflowInfo"
}

// GetAction returns the Action field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetAction() string {
	if o == nil || IsNil(o.Action) {
		var ret string
		return ret
	}
	return *o.Action
}

// GetActionOk returns a tuple with the Action field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetActionOk() (*string, bool) {
	if o == nil || IsNil(o.Action) {
		return nil, false
	}
	return o.Action, true
}

// HasAction returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasAction() bool {
	if o != nil && !IsNil(o.Action) {
		return true
	}

	return false
}

// SetAction gets a reference to the given string and assigns it to the Action field.
func (o *WorkflowWorkflowInfo) SetAction(v string) {
	o.Action = &v
}

// GetCleanupTime returns the CleanupTime field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetCleanupTime() time.Time {
	if o == nil || IsNil(o.CleanupTime) {
		var ret time.Time
		return ret
	}
	return *o.CleanupTime
}

// GetCleanupTimeOk returns a tuple with the CleanupTime field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetCleanupTimeOk() (*time.Time, bool) {
	if o == nil || IsNil(o.CleanupTime) {
		return nil, false
	}
	return o.CleanupTime, true
}

// HasCleanupTime returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasCleanupTime() bool {
	if o != nil && !IsNil(o.CleanupTime) {
		return true
	}

	return false
}

// SetCleanupTime gets a reference to the given time.Time and assigns it to the CleanupTime field.
func (o *WorkflowWorkflowInfo) SetCleanupTime(v time.Time) {
	o.CleanupTime = &v
}

// GetEmail returns the Email field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetEmail() string {
	if o == nil || IsNil(o.Email) {
		var ret string
		return ret
	}
	return *o.Email
}

// GetEmailOk returns a tuple with the Email field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetEmailOk() (*string, bool) {
	if o == nil || IsNil(o.Email) {
		return nil, false
	}
	return o.Email, true
}

// HasEmail returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasEmail() bool {
	if o != nil && !IsNil(o.Email) {
		return true
	}

	return false
}

// SetEmail gets a reference to the given string and assigns it to the Email field.
func (o *WorkflowWorkflowInfo) SetEmail(v string) {
	o.Email = &v
}

// GetEndTime returns the EndTime field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetEndTime() time.Time {
	if o == nil || IsNil(o.EndTime) {
		var ret time.Time
		return ret
	}
	return *o.EndTime
}

// GetEndTimeOk returns a tuple with the EndTime field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetEndTimeOk() (*time.Time, bool) {
	if o == nil || IsNil(o.EndTime) {
		return nil, false
	}
	return o.EndTime, true
}

// HasEndTime returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasEndTime() bool {
	if o != nil && !IsNil(o.EndTime) {
		return true
	}

	return false
}

// SetEndTime gets a reference to the given time.Time and assigns it to the EndTime field.
func (o *WorkflowWorkflowInfo) SetEndTime(v time.Time) {
	o.EndTime = &v
}

// GetFailedWorkflowCleanupDuration returns the FailedWorkflowCleanupDuration field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetFailedWorkflowCleanupDuration() int64 {
	if o == nil || IsNil(o.FailedWorkflowCleanupDuration) {
		var ret int64
		return ret
	}
	return *o.FailedWorkflowCleanupDuration
}

// GetFailedWorkflowCleanupDurationOk returns a tuple with the FailedWorkflowCleanupDuration field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetFailedWorkflowCleanupDurationOk() (*int64, bool) {
	if o == nil || IsNil(o.FailedWorkflowCleanupDuration) {
		return nil, false
	}
	return o.FailedWorkflowCleanupDuration, true
}

// HasFailedWorkflowCleanupDuration returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasFailedWorkflowCleanupDuration() bool {
	if o != nil && !IsNil(o.FailedWorkflowCleanupDuration) {
		return true
	}

	return false
}

// SetFailedWorkflowCleanupDuration gets a reference to the given int64 and assigns it to the FailedWorkflowCleanupDuration field.
func (o *WorkflowWorkflowInfo) SetFailedWorkflowCleanupDuration(v int64) {
	o.FailedWorkflowCleanupDuration = &v
}

// GetInput returns the Input field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetInput() interface{} {
	if o == nil {
		var ret interface{}
		return ret
	}
	return o.Input
}

// GetInputOk returns a tuple with the Input field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetInputOk() (*interface{}, bool) {
	if o == nil || IsNil(o.Input) {
		return nil, false
	}
	return &o.Input, true
}

// HasInput returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasInput() bool {
	if o != nil && !IsNil(o.Input) {
		return true
	}

	return false
}

// SetInput gets a reference to the given interface{} and assigns it to the Input field.
func (o *WorkflowWorkflowInfo) SetInput(v interface{}) {
	o.Input = v
}

// GetInstId returns the InstId field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetInstId() string {
	if o == nil || IsNil(o.InstId) {
		var ret string
		return ret
	}
	return *o.InstId
}

// GetInstIdOk returns a tuple with the InstId field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetInstIdOk() (*string, bool) {
	if o == nil || IsNil(o.InstId) {
		return nil, false
	}
	return o.InstId, true
}

// HasInstId returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasInstId() bool {
	if o != nil && !IsNil(o.InstId) {
		return true
	}

	return false
}

// SetInstId gets a reference to the given string and assigns it to the InstId field.
func (o *WorkflowWorkflowInfo) SetInstId(v string) {
	o.InstId = &v
}

// GetInternal returns the Internal field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetInternal() bool {
	if o == nil || IsNil(o.Internal) {
		var ret bool
		return ret
	}
	return *o.Internal
}

// GetInternalOk returns a tuple with the Internal field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetInternalOk() (*bool, bool) {
	if o == nil || IsNil(o.Internal) {
		return nil, false
	}
	return o.Internal, true
}

// HasInternal returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasInternal() bool {
	if o != nil && !IsNil(o.Internal) {
		return true
	}

	return false
}

// SetInternal gets a reference to the given bool and assigns it to the Internal field.
func (o *WorkflowWorkflowInfo) SetInternal(v bool) {
	o.Internal = &v
}

// GetLastAction returns the LastAction field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetLastAction() string {
	if o == nil || IsNil(o.LastAction) {
		var ret string
		return ret
	}
	return *o.LastAction
}

// GetLastActionOk returns a tuple with the LastAction field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetLastActionOk() (*string, bool) {
	if o == nil || IsNil(o.LastAction) {
		return nil, false
	}
	return o.LastAction, true
}

// HasLastAction returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasLastAction() bool {
	if o != nil && !IsNil(o.LastAction) {
		return true
	}

	return false
}

// SetLastAction gets a reference to the given string and assigns it to the LastAction field.
func (o *WorkflowWorkflowInfo) SetLastAction(v string) {
	o.LastAction = &v
}

// GetMessage returns the Message field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetMessage() []WorkflowMessage {
	if o == nil {
		var ret []WorkflowMessage
		return ret
	}
	return o.Message
}

// GetMessageOk returns a tuple with the Message field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetMessageOk() ([]WorkflowMessage, bool) {
	if o == nil || IsNil(o.Message) {
		return nil, false
	}
	return o.Message, true
}

// HasMessage returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasMessage() bool {
	if o != nil && !IsNil(o.Message) {
		return true
	}

	return false
}

// SetMessage gets a reference to the given []WorkflowMessage and assigns it to the Message field.
func (o *WorkflowWorkflowInfo) SetMessage(v []WorkflowMessage) {
	o.Message = v
}

// GetName returns the Name field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetName() string {
	if o == nil || IsNil(o.Name) {
		var ret string
		return ret
	}
	return *o.Name
}

// GetNameOk returns a tuple with the Name field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetNameOk() (*string, bool) {
	if o == nil || IsNil(o.Name) {
		return nil, false
	}
	return o.Name, true
}

// HasName returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasName() bool {
	if o != nil && !IsNil(o.Name) {
		return true
	}

	return false
}

// SetName gets a reference to the given string and assigns it to the Name field.
func (o *WorkflowWorkflowInfo) SetName(v string) {
	o.Name = &v
}

// GetOutput returns the Output field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetOutput() interface{} {
	if o == nil {
		var ret interface{}
		return ret
	}
	return o.Output
}

// GetOutputOk returns a tuple with the Output field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetOutputOk() (*interface{}, bool) {
	if o == nil || IsNil(o.Output) {
		return nil, false
	}
	return &o.Output, true
}

// HasOutput returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasOutput() bool {
	if o != nil && !IsNil(o.Output) {
		return true
	}

	return false
}

// SetOutput gets a reference to the given interface{} and assigns it to the Output field.
func (o *WorkflowWorkflowInfo) SetOutput(v interface{}) {
	o.Output = v
}

// GetPauseReason returns the PauseReason field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetPauseReason() string {
	if o == nil || IsNil(o.PauseReason) {
		var ret string
		return ret
	}
	return *o.PauseReason
}

// GetPauseReasonOk returns a tuple with the PauseReason field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetPauseReasonOk() (*string, bool) {
	if o == nil || IsNil(o.PauseReason) {
		return nil, false
	}
	return o.PauseReason, true
}

// HasPauseReason returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasPauseReason() bool {
	if o != nil && !IsNil(o.PauseReason) {
		return true
	}

	return false
}

// SetPauseReason gets a reference to the given string and assigns it to the PauseReason field.
func (o *WorkflowWorkflowInfo) SetPauseReason(v string) {
	o.PauseReason = &v
}

// GetProgress returns the Progress field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetProgress() float32 {
	if o == nil || IsNil(o.Progress) {
		var ret float32
		return ret
	}
	return *o.Progress
}

// GetProgressOk returns a tuple with the Progress field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetProgressOk() (*float32, bool) {
	if o == nil || IsNil(o.Progress) {
		return nil, false
	}
	return o.Progress, true
}

// HasProgress returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasProgress() bool {
	if o != nil && !IsNil(o.Progress) {
		return true
	}

	return false
}

// SetProgress gets a reference to the given float32 and assigns it to the Progress field.
func (o *WorkflowWorkflowInfo) SetProgress(v float32) {
	o.Progress = &v
}

// GetProperties returns the Properties field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetProperties() WorkflowWorkflowInfoProperties {
	if o == nil || IsNil(o.Properties.Get()) {
		var ret WorkflowWorkflowInfoProperties
		return ret
	}
	return *o.Properties.Get()
}

// GetPropertiesOk returns a tuple with the Properties field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetPropertiesOk() (*WorkflowWorkflowInfoProperties, bool) {
	if o == nil {
		return nil, false
	}
	return o.Properties.Get(), o.Properties.IsSet()
}

// HasProperties returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasProperties() bool {
	if o != nil && o.Properties.IsSet() {
		return true
	}

	return false
}

// SetProperties gets a reference to the given NullableWorkflowWorkflowInfoProperties and assigns it to the Properties field.
func (o *WorkflowWorkflowInfo) SetProperties(v WorkflowWorkflowInfoProperties) {
	o.Properties.Set(&v)
}

// SetPropertiesNil sets the value for Properties to be an explicit nil
func (o *WorkflowWorkflowInfo) SetPropertiesNil() {
	o.Properties.Set(nil)
}

// UnsetProperties ensures that no value is present for Properties, not even an explicit nil
func (o *WorkflowWorkflowInfo) UnsetProperties() {
	o.Properties.Unset()
}

// GetRetryFromTaskName returns the RetryFromTaskName field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetRetryFromTaskName() string {
	if o == nil || IsNil(o.RetryFromTaskName) {
		var ret string
		return ret
	}
	return *o.RetryFromTaskName
}

// GetRetryFromTaskNameOk returns a tuple with the RetryFromTaskName field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetRetryFromTaskNameOk() (*string, bool) {
	if o == nil || IsNil(o.RetryFromTaskName) {
		return nil, false
	}
	return o.RetryFromTaskName, true
}

// HasRetryFromTaskName returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasRetryFromTaskName() bool {
	if o != nil && !IsNil(o.RetryFromTaskName) {
		return true
	}

	return false
}

// SetRetryFromTaskName gets a reference to the given string and assigns it to the RetryFromTaskName field.
func (o *WorkflowWorkflowInfo) SetRetryFromTaskName(v string) {
	o.RetryFromTaskName = &v
}

// GetSrc returns the Src field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetSrc() string {
	if o == nil || IsNil(o.Src) {
		var ret string
		return ret
	}
	return *o.Src
}

// GetSrcOk returns a tuple with the Src field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetSrcOk() (*string, bool) {
	if o == nil || IsNil(o.Src) {
		return nil, false
	}
	return o.Src, true
}

// HasSrc returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasSrc() bool {
	if o != nil && !IsNil(o.Src) {
		return true
	}

	return false
}

// SetSrc gets a reference to the given string and assigns it to the Src field.
func (o *WorkflowWorkflowInfo) SetSrc(v string) {
	o.Src = &v
}

// GetStartTime returns the StartTime field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetStartTime() time.Time {
	if o == nil || IsNil(o.StartTime) {
		var ret time.Time
		return ret
	}
	return *o.StartTime
}

// GetStartTimeOk returns a tuple with the StartTime field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetStartTimeOk() (*time.Time, bool) {
	if o == nil || IsNil(o.StartTime) {
		return nil, false
	}
	return o.StartTime, true
}

// HasStartTime returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasStartTime() bool {
	if o != nil && !IsNil(o.StartTime) {
		return true
	}

	return false
}

// SetStartTime gets a reference to the given time.Time and assigns it to the StartTime field.
func (o *WorkflowWorkflowInfo) SetStartTime(v time.Time) {
	o.StartTime = &v
}

// GetStatus returns the Status field value if set, zero value otherwise.
// Deprecated
func (o *WorkflowWorkflowInfo) GetStatus() string {
	if o == nil || IsNil(o.Status) {
		var ret string
		return ret
	}
	return *o.Status
}

// GetStatusOk returns a tuple with the Status field value if set, nil otherwise
// and a boolean to check if the value has been set.
// Deprecated
func (o *WorkflowWorkflowInfo) GetStatusOk() (*string, bool) {
	if o == nil || IsNil(o.Status) {
		return nil, false
	}
	return o.Status, true
}

// HasStatus returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasStatus() bool {
	if o != nil && !IsNil(o.Status) {
		return true
	}

	return false
}

// SetStatus gets a reference to the given string and assigns it to the Status field.
// Deprecated
func (o *WorkflowWorkflowInfo) SetStatus(v string) {
	o.Status = &v
}

// GetSuccessWorkflowCleanupDuration returns the SuccessWorkflowCleanupDuration field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetSuccessWorkflowCleanupDuration() int64 {
	if o == nil || IsNil(o.SuccessWorkflowCleanupDuration) {
		var ret int64
		return ret
	}
	return *o.SuccessWorkflowCleanupDuration
}

// GetSuccessWorkflowCleanupDurationOk returns a tuple with the SuccessWorkflowCleanupDuration field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetSuccessWorkflowCleanupDurationOk() (*int64, bool) {
	if o == nil || IsNil(o.SuccessWorkflowCleanupDuration) {
		return nil, false
	}
	return o.SuccessWorkflowCleanupDuration, true
}

// HasSuccessWorkflowCleanupDuration returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasSuccessWorkflowCleanupDuration() bool {
	if o != nil && !IsNil(o.SuccessWorkflowCleanupDuration) {
		return true
	}

	return false
}

// SetSuccessWorkflowCleanupDuration gets a reference to the given int64 and assigns it to the SuccessWorkflowCleanupDuration field.
func (o *WorkflowWorkflowInfo) SetSuccessWorkflowCleanupDuration(v int64) {
	o.SuccessWorkflowCleanupDuration = &v
}

// GetTaskInfoUpdate returns the TaskInfoUpdate field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetTaskInfoUpdate() WorkflowTaskInfoUpdate {
	if o == nil || IsNil(o.TaskInfoUpdate.Get()) {
		var ret WorkflowTaskInfoUpdate
		return ret
	}
	return *o.TaskInfoUpdate.Get()
}

// GetTaskInfoUpdateOk returns a tuple with the TaskInfoUpdate field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetTaskInfoUpdateOk() (*WorkflowTaskInfoUpdate, bool) {
	if o == nil {
		return nil, false
	}
	return o.TaskInfoUpdate.Get(), o.TaskInfoUpdate.IsSet()
}

// HasTaskInfoUpdate returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasTaskInfoUpdate() bool {
	if o != nil && o.TaskInfoUpdate.IsSet() {
		return true
	}

	return false
}

// SetTaskInfoUpdate gets a reference to the given NullableWorkflowTaskInfoUpdate and assigns it to the TaskInfoUpdate field.
func (o *WorkflowWorkflowInfo) SetTaskInfoUpdate(v WorkflowTaskInfoUpdate) {
	o.TaskInfoUpdate.Set(&v)
}

// SetTaskInfoUpdateNil sets the value for TaskInfoUpdate to be an explicit nil
func (o *WorkflowWorkflowInfo) SetTaskInfoUpdateNil() {
	o.TaskInfoUpdate.Set(nil)
}

// UnsetTaskInfoUpdate ensures that no value is present for TaskInfoUpdate, not even an explicit nil
func (o *WorkflowWorkflowInfo) UnsetTaskInfoUpdate() {
	o.TaskInfoUpdate.Unset()
}

// GetTraceId returns the TraceId field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetTraceId() string {
	if o == nil || IsNil(o.TraceId) {
		var ret string
		return ret
	}
	return *o.TraceId
}

// GetTraceIdOk returns a tuple with the TraceId field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetTraceIdOk() (*string, bool) {
	if o == nil || IsNil(o.TraceId) {
		return nil, false
	}
	return o.TraceId, true
}

// HasTraceId returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasTraceId() bool {
	if o != nil && !IsNil(o.TraceId) {
		return true
	}

	return false
}

// SetTraceId gets a reference to the given string and assigns it to the TraceId field.
func (o *WorkflowWorkflowInfo) SetTraceId(v string) {
	o.TraceId = &v
}

// GetType returns the Type field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetType() string {
	if o == nil || IsNil(o.Type) {
		var ret string
		return ret
	}
	return *o.Type
}

// GetTypeOk returns a tuple with the Type field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetTypeOk() (*string, bool) {
	if o == nil || IsNil(o.Type) {
		return nil, false
	}
	return o.Type, true
}

// HasType returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasType() bool {
	if o != nil && !IsNil(o.Type) {
		return true
	}

	return false
}

// SetType gets a reference to the given string and assigns it to the Type field.
func (o *WorkflowWorkflowInfo) SetType(v string) {
	o.Type = &v
}

// GetUserActionRequired returns the UserActionRequired field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetUserActionRequired() bool {
	if o == nil || IsNil(o.UserActionRequired) {
		var ret bool
		return ret
	}
	return *o.UserActionRequired
}

// GetUserActionRequiredOk returns a tuple with the UserActionRequired field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetUserActionRequiredOk() (*bool, bool) {
	if o == nil || IsNil(o.UserActionRequired) {
		return nil, false
	}
	return o.UserActionRequired, true
}

// HasUserActionRequired returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasUserActionRequired() bool {
	if o != nil && !IsNil(o.UserActionRequired) {
		return true
	}

	return false
}

// SetUserActionRequired gets a reference to the given bool and assigns it to the UserActionRequired field.
func (o *WorkflowWorkflowInfo) SetUserActionRequired(v bool) {
	o.UserActionRequired = &v
}

// GetUserId returns the UserId field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetUserId() string {
	if o == nil || IsNil(o.UserId) {
		var ret string
		return ret
	}
	return *o.UserId
}

// GetUserIdOk returns a tuple with the UserId field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetUserIdOk() (*string, bool) {
	if o == nil || IsNil(o.UserId) {
		return nil, false
	}
	return o.UserId, true
}

// HasUserId returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasUserId() bool {
	if o != nil && !IsNil(o.UserId) {
		return true
	}

	return false
}

// SetUserId gets a reference to the given string and assigns it to the UserId field.
func (o *WorkflowWorkflowInfo) SetUserId(v string) {
	o.UserId = &v
}

// GetVariable returns the Variable field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetVariable() interface{} {
	if o == nil {
		var ret interface{}
		return ret
	}
	return o.Variable
}

// GetVariableOk returns a tuple with the Variable field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetVariableOk() (*interface{}, bool) {
	if o == nil || IsNil(o.Variable) {
		return nil, false
	}
	return &o.Variable, true
}

// HasVariable returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasVariable() bool {
	if o != nil && !IsNil(o.Variable) {
		return true
	}

	return false
}

// SetVariable gets a reference to the given interface{} and assigns it to the Variable field.
func (o *WorkflowWorkflowInfo) SetVariable(v interface{}) {
	o.Variable = v
}

// GetWaitReason returns the WaitReason field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetWaitReason() string {
	if o == nil || IsNil(o.WaitReason) {
		var ret string
		return ret
	}
	return *o.WaitReason
}

// GetWaitReasonOk returns a tuple with the WaitReason field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetWaitReasonOk() (*string, bool) {
	if o == nil || IsNil(o.WaitReason) {
		return nil, false
	}
	return o.WaitReason, true
}

// HasWaitReason returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasWaitReason() bool {
	if o != nil && !IsNil(o.WaitReason) {
		return true
	}

	return false
}

// SetWaitReason gets a reference to the given string and assigns it to the WaitReason field.
func (o *WorkflowWorkflowInfo) SetWaitReason(v string) {
	o.WaitReason = &v
}

// GetWorkflowCtx returns the WorkflowCtx field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetWorkflowCtx() WorkflowWorkflowCtx {
	if o == nil || IsNil(o.WorkflowCtx.Get()) {
		var ret WorkflowWorkflowCtx
		return ret
	}
	return *o.WorkflowCtx.Get()
}

// GetWorkflowCtxOk returns a tuple with the WorkflowCtx field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetWorkflowCtxOk() (*WorkflowWorkflowCtx, bool) {
	if o == nil {
		return nil, false
	}
	return o.WorkflowCtx.Get(), o.WorkflowCtx.IsSet()
}

// HasWorkflowCtx returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasWorkflowCtx() bool {
	if o != nil && o.WorkflowCtx.IsSet() {
		return true
	}

	return false
}

// SetWorkflowCtx gets a reference to the given NullableWorkflowWorkflowCtx and assigns it to the WorkflowCtx field.
func (o *WorkflowWorkflowInfo) SetWorkflowCtx(v WorkflowWorkflowCtx) {
	o.WorkflowCtx.Set(&v)
}

// SetWorkflowCtxNil sets the value for WorkflowCtx to be an explicit nil
func (o *WorkflowWorkflowInfo) SetWorkflowCtxNil() {
	o.WorkflowCtx.Set(nil)
}

// UnsetWorkflowCtx ensures that no value is present for WorkflowCtx, not even an explicit nil
func (o *WorkflowWorkflowInfo) UnsetWorkflowCtx() {
	o.WorkflowCtx.Unset()
}

// GetWorkflowStatus returns the WorkflowStatus field value if set, zero value otherwise.
func (o *WorkflowWorkflowInfo) GetWorkflowStatus() string {
	if o == nil || IsNil(o.WorkflowStatus) {
		var ret string
		return ret
	}
	return *o.WorkflowStatus
}

// GetWorkflowStatusOk returns a tuple with the WorkflowStatus field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *WorkflowWorkflowInfo) GetWorkflowStatusOk() (*string, bool) {
	if o == nil || IsNil(o.WorkflowStatus) {
		return nil, false
	}
	return o.WorkflowStatus, true
}

// HasWorkflowStatus returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasWorkflowStatus() bool {
	if o != nil && !IsNil(o.WorkflowStatus) {
		return true
	}

	return false
}

// SetWorkflowStatus gets a reference to the given string and assigns it to the WorkflowStatus field.
func (o *WorkflowWorkflowInfo) SetWorkflowStatus(v string) {
	o.WorkflowStatus = &v
}

// GetAccount returns the Account field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetAccount() IamAccountRelationship {
	if o == nil || IsNil(o.Account.Get()) {
		var ret IamAccountRelationship
		return ret
	}
	return *o.Account.Get()
}

// GetAccountOk returns a tuple with the Account field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetAccountOk() (*IamAccountRelationship, bool) {
	if o == nil {
		return nil, false
	}
	return o.Account.Get(), o.Account.IsSet()
}

// HasAccount returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasAccount() bool {
	if o != nil && o.Account.IsSet() {
		return true
	}

	return false
}

// SetAccount gets a reference to the given NullableIamAccountRelationship and assigns it to the Account field.
func (o *WorkflowWorkflowInfo) SetAccount(v IamAccountRelationship) {
	o.Account.Set(&v)
}

// SetAccountNil sets the value for Account to be an explicit nil
func (o *WorkflowWorkflowInfo) SetAccountNil() {
	o.Account.Set(nil)
}

// UnsetAccount ensures that no value is present for Account, not even an explicit nil
func (o *WorkflowWorkflowInfo) UnsetAccount() {
	o.Account.Unset()
}

// GetAssociatedObject returns the AssociatedObject field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetAssociatedObject() MoBaseMoRelationship {
	if o == nil || IsNil(o.AssociatedObject.Get()) {
		var ret MoBaseMoRelationship
		return ret
	}
	return *o.AssociatedObject.Get()
}

// GetAssociatedObjectOk returns a tuple with the AssociatedObject field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetAssociatedObjectOk() (*MoBaseMoRelationship, bool) {
	if o == nil {
		return nil, false
	}
	return o.AssociatedObject.Get(), o.AssociatedObject.IsSet()
}

// HasAssociatedObject returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasAssociatedObject() bool {
	if o != nil && o.AssociatedObject.IsSet() {
		return true
	}

	return false
}

// SetAssociatedObject gets a reference to the given NullableMoBaseMoRelationship and assigns it to the AssociatedObject field.
func (o *WorkflowWorkflowInfo) SetAssociatedObject(v MoBaseMoRelationship) {
	o.AssociatedObject.Set(&v)
}

// SetAssociatedObjectNil sets the value for AssociatedObject to be an explicit nil
func (o *WorkflowWorkflowInfo) SetAssociatedObjectNil() {
	o.AssociatedObject.Set(nil)
}

// UnsetAssociatedObject ensures that no value is present for AssociatedObject, not even an explicit nil
func (o *WorkflowWorkflowInfo) UnsetAssociatedObject() {
	o.AssociatedObject.Unset()
}

// GetOrganization returns the Organization field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetOrganization() OrganizationOrganizationRelationship {
	if o == nil || IsNil(o.Organization.Get()) {
		var ret OrganizationOrganizationRelationship
		return ret
	}
	return *o.Organization.Get()
}

// GetOrganizationOk returns a tuple with the Organization field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetOrganizationOk() (*OrganizationOrganizationRelationship, bool) {
	if o == nil {
		return nil, false
	}
	return o.Organization.Get(), o.Organization.IsSet()
}

// HasOrganization returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasOrganization() bool {
	if o != nil && o.Organization.IsSet() {
		return true
	}

	return false
}

// SetOrganization gets a reference to the given NullableOrganizationOrganizationRelationship and assigns it to the Organization field.
func (o *WorkflowWorkflowInfo) SetOrganization(v OrganizationOrganizationRelationship) {
	o.Organization.Set(&v)
}

// SetOrganizationNil sets the value for Organization to be an explicit nil
func (o *WorkflowWorkflowInfo) SetOrganizationNil() {
	o.Organization.Set(nil)
}

// UnsetOrganization ensures that no value is present for Organization, not even an explicit nil
func (o *WorkflowWorkflowInfo) UnsetOrganization() {
	o.Organization.Unset()
}

// GetParentTaskInfo returns the ParentTaskInfo field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetParentTaskInfo() WorkflowTaskInfoRelationship {
	if o == nil || IsNil(o.ParentTaskInfo.Get()) {
		var ret WorkflowTaskInfoRelationship
		return ret
	}
	return *o.ParentTaskInfo.Get()
}

// GetParentTaskInfoOk returns a tuple with the ParentTaskInfo field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetParentTaskInfoOk() (*WorkflowTaskInfoRelationship, bool) {
	if o == nil {
		return nil, false
	}
	return o.ParentTaskInfo.Get(), o.ParentTaskInfo.IsSet()
}

// HasParentTaskInfo returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasParentTaskInfo() bool {
	if o != nil && o.ParentTaskInfo.IsSet() {
		return true
	}

	return false
}

// SetParentTaskInfo gets a reference to the given NullableWorkflowTaskInfoRelationship and assigns it to the ParentTaskInfo field.
func (o *WorkflowWorkflowInfo) SetParentTaskInfo(v WorkflowTaskInfoRelationship) {
	o.ParentTaskInfo.Set(&v)
}

// SetParentTaskInfoNil sets the value for ParentTaskInfo to be an explicit nil
func (o *WorkflowWorkflowInfo) SetParentTaskInfoNil() {
	o.ParentTaskInfo.Set(nil)
}

// UnsetParentTaskInfo ensures that no value is present for ParentTaskInfo, not even an explicit nil
func (o *WorkflowWorkflowInfo) UnsetParentTaskInfo() {
	o.ParentTaskInfo.Unset()
}

// GetPermission returns the Permission field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetPermission() IamPermissionRelationship {
	if o == nil || IsNil(o.Permission.Get()) {
		var ret IamPermissionRelationship
		return ret
	}
	return *o.Permission.Get()
}

// GetPermissionOk returns a tuple with the Permission field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetPermissionOk() (*IamPermissionRelationship, bool) {
	if o == nil {
		return nil, false
	}
	return o.Permission.Get(), o.Permission.IsSet()
}

// HasPermission returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasPermission() bool {
	if o != nil && o.Permission.IsSet() {
		return true
	}

	return false
}

// SetPermission gets a reference to the given NullableIamPermissionRelationship and assigns it to the Permission field.
func (o *WorkflowWorkflowInfo) SetPermission(v IamPermissionRelationship) {
	o.Permission.Set(&v)
}

// SetPermissionNil sets the value for Permission to be an explicit nil
func (o *WorkflowWorkflowInfo) SetPermissionNil() {
	o.Permission.Set(nil)
}

// UnsetPermission ensures that no value is present for Permission, not even an explicit nil
func (o *WorkflowWorkflowInfo) UnsetPermission() {
	o.Permission.Unset()
}

// GetTaskInfos returns the TaskInfos field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetTaskInfos() []WorkflowTaskInfoRelationship {
	if o == nil {
		var ret []WorkflowTaskInfoRelationship
		return ret
	}
	return o.TaskInfos
}

// GetTaskInfosOk returns a tuple with the TaskInfos field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetTaskInfosOk() ([]WorkflowTaskInfoRelationship, bool) {
	if o == nil || IsNil(o.TaskInfos) {
		return nil, false
	}
	return o.TaskInfos, true
}

// HasTaskInfos returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasTaskInfos() bool {
	if o != nil && !IsNil(o.TaskInfos) {
		return true
	}

	return false
}

// SetTaskInfos gets a reference to the given []WorkflowTaskInfoRelationship and assigns it to the TaskInfos field.
func (o *WorkflowWorkflowInfo) SetTaskInfos(v []WorkflowTaskInfoRelationship) {
	o.TaskInfos = v
}

// GetWorkflowDefinition returns the WorkflowDefinition field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *WorkflowWorkflowInfo) GetWorkflowDefinition() WorkflowWorkflowDefinitionRelationship {
	if o == nil || IsNil(o.WorkflowDefinition.Get()) {
		var ret WorkflowWorkflowDefinitionRelationship
		return ret
	}
	return *o.WorkflowDefinition.Get()
}

// GetWorkflowDefinitionOk returns a tuple with the WorkflowDefinition field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *WorkflowWorkflowInfo) GetWorkflowDefinitionOk() (*WorkflowWorkflowDefinitionRelationship, bool) {
	if o == nil {
		return nil, false
	}
	return o.WorkflowDefinition.Get(), o.WorkflowDefinition.IsSet()
}

// HasWorkflowDefinition returns a boolean if a field has been set.
func (o *WorkflowWorkflowInfo) HasWorkflowDefinition() bool {
	if o != nil && o.WorkflowDefinition.IsSet() {
		return true
	}

	return false
}

// SetWorkflowDefinition gets a reference to the given NullableWorkflowWorkflowDefinitionRelationship and assigns it to the WorkflowDefinition field.
func (o *WorkflowWorkflowInfo) SetWorkflowDefinition(v WorkflowWorkflowDefinitionRelationship) {
	o.WorkflowDefinition.Set(&v)
}

// SetWorkflowDefinitionNil sets the value for WorkflowDefinition to be an explicit nil
func (o *WorkflowWorkflowInfo) SetWorkflowDefinitionNil() {
	o.WorkflowDefinition.Set(nil)
}

// UnsetWorkflowDefinition ensures that no value is present for WorkflowDefinition, not even an explicit nil
func (o *WorkflowWorkflowInfo) UnsetWorkflowDefinition() {
	o.WorkflowDefinition.Unset()
}

func (o WorkflowWorkflowInfo) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o WorkflowWorkflowInfo) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	serializedMoBaseMo, errMoBaseMo := json.Marshal(o.MoBaseMo)
	if errMoBaseMo != nil {
		return map[string]interface{}{}, errMoBaseMo
	}
	errMoBaseMo = json.Unmarshal([]byte(serializedMoBaseMo), &toSerialize)
	if errMoBaseMo != nil {
		return map[string]interface{}{}, errMoBaseMo
	}
	if _, exists := toSerialize["ClassId"]; !exists {
		toSerialize["ClassId"] = o.GetDefaultClassId()
	}
	toSerialize["ClassId"] = o.ClassId
	if _, exists := toSerialize["ObjectType"]; !exists {
		toSerialize["ObjectType"] = o.GetDefaultObjectType()
	}
	toSerialize["ObjectType"] = o.ObjectType
	if !IsNil(o.Action) {
		toSerialize["Action"] = o.Action
	}
	if !IsNil(o.CleanupTime) {
		toSerialize["CleanupTime"] = o.CleanupTime
	}
	if !IsNil(o.Email) {
		toSerialize["Email"] = o.Email
	}
	if !IsNil(o.EndTime) {
		toSerialize["EndTime"] = o.EndTime
	}
	if !IsNil(o.FailedWorkflowCleanupDuration) {
		toSerialize["FailedWorkflowCleanupDuration"] = o.FailedWorkflowCleanupDuration
	}
	if o.Input != nil {
		toSerialize["Input"] = o.Input
	}
	if !IsNil(o.InstId) {
		toSerialize["InstId"] = o.InstId
	}
	if !IsNil(o.Internal) {
		toSerialize["Internal"] = o.Internal
	}
	if !IsNil(o.LastAction) {
		toSerialize["LastAction"] = o.LastAction
	}
	if o.Message != nil {
		toSerialize["Message"] = o.Message
	}
	if !IsNil(o.Name) {
		toSerialize["Name"] = o.Name
	}
	if o.Output != nil {
		toSerialize["Output"] = o.Output
	}
	if !IsNil(o.PauseReason) {
		toSerialize["PauseReason"] = o.PauseReason
	}
	if !IsNil(o.Progress) {
		toSerialize["Progress"] = o.Progress
	}
	if o.Properties.IsSet() {
		toSerialize["Properties"] = o.Properties.Get()
	}
	if !IsNil(o.RetryFromTaskName) {
		toSerialize["RetryFromTaskName"] = o.RetryFromTaskName
	}
	if !IsNil(o.Src) {
		toSerialize["Src"] = o.Src
	}
	if !IsNil(o.StartTime) {
		toSerialize["StartTime"] = o.StartTime
	}
	if !IsNil(o.Status) {
		toSerialize["Status"] = o.Status
	}
	if !IsNil(o.SuccessWorkflowCleanupDuration) {
		toSerialize["SuccessWorkflowCleanupDuration"] = o.SuccessWorkflowCleanupDuration
	}
	if o.TaskInfoUpdate.IsSet() {
		toSerialize["TaskInfoUpdate"] = o.TaskInfoUpdate.Get()
	}
	if !IsNil(o.TraceId) {
		toSerialize["TraceId"] = o.TraceId
	}
	if !IsNil(o.Type) {
		toSerialize["Type"] = o.Type
	}
	if !IsNil(o.UserActionRequired) {
		toSerialize["UserActionRequired"] = o.UserActionRequired
	}
	if !IsNil(o.UserId) {
		toSerialize["UserId"] = o.UserId
	}
	if o.Variable != nil {
		toSerialize["Variable"] = o.Variable
	}
	if !IsNil(o.WaitReason) {
		toSerialize["WaitReason"] = o.WaitReason
	}
	if o.WorkflowCtx.IsSet() {
		toSerialize["WorkflowCtx"] = o.WorkflowCtx.Get()
	}
	if !IsNil(o.WorkflowStatus) {
		toSerialize["WorkflowStatus"] = o.WorkflowStatus
	}
	if o.Account.IsSet() {
		toSerialize["Account"] = o.Account.Get()
	}
	if o.AssociatedObject.IsSet() {
		toSerialize["AssociatedObject"] = o.AssociatedObject.Get()
	}
	if o.Organization.IsSet() {
		toSerialize["Organization"] = o.Organization.Get()
	}
	if o.ParentTaskInfo.IsSet() {
		toSerialize["ParentTaskInfo"] = o.ParentTaskInfo.Get()
	}
	if o.Permission.IsSet() {
		toSerialize["Permission"] = o.Permission.Get()
	}
	if o.TaskInfos != nil {
		toSerialize["TaskInfos"] = o.TaskInfos
	}
	if o.WorkflowDefinition.IsSet() {
		toSerialize["WorkflowDefinition"] = o.WorkflowDefinition.Get()
	}

	for key, value := range o.AdditionalProperties {
		toSerialize[key] = value
	}

	return toSerialize, nil
}

func (o *WorkflowWorkflowInfo) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"ClassId",
		"ObjectType",
	}

	// defaultValueFuncMap captures the default values for required properties.
	// These values are used when required properties are missing from the payload.
	defaultValueFuncMap := map[string]func() interface{}{
		"ClassId":    o.GetDefaultClassId,
		"ObjectType": o.GetDefaultObjectType,
	}
	var defaultValueApplied bool
	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err
	}

	for _, requiredProperty := range requiredProperties {
		if value, exists := allProperties[requiredProperty]; !exists || value == "" {
			if _, ok := defaultValueFuncMap[requiredProperty]; ok {
				allProperties[requiredProperty] = defaultValueFuncMap[requiredProperty]()
				defaultValueApplied = true
			}
		}
		if value, exists := allProperties[requiredProperty]; !exists || value == "" {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	if defaultValueApplied {
		data, err = json.Marshal(allProperties)
		if err != nil {
			return err
		}
	}
	type WorkflowWorkflowInfoWithoutEmbeddedStruct struct {
		// The fully-qualified name of the instantiated, concrete type. This property is used as a discriminator to identify the type of the payload when marshaling and unmarshaling data.
		ClassId string `json:"ClassId"`
		// The fully-qualified name of the instantiated, concrete type. The value should be the same as the 'ClassId' property.
		ObjectType string `json:"ObjectType"`
		// The action of the workflow such as start, cancel, retry, pause. * `None` - No action is set, this is the default value for action field. * `Create` - Create a new instance of the workflow but it does not start the execution of the workflow. Use the Start action to start execution of the workflow. * `Start` - Start a new execution of the workflow. * `Pause` - Pause the workflow, this can only be issued on workflows that are in running state. A workflow can be paused for a maximum of 180 days, after 180 days the workflow will be terminated by the system. * `Resume` - Resume the workflow which was previously paused through pause action on the workflow. * `Rerun` - Rerun the workflow that has previously reached a failed state. The workflow is run from the beginning using inputs from previous execution. Completed and currently running workflows cannot be rerun. Workflows do not have to be marked for retry to use this action. * `Retry` - This action has been deprecated. Please use RetryFailed, Rerun or RetryFromTask action. Retry the workflow that has previously reached a final state and has the retryable property set to true. A running or waiting workflow cannot be retried. If the property retryFromTaskName is also passed along with this action, the workflow will be started from that specific task, otherwise the workflow will be restarted from the first task.  The task name in retryFromTaskName must be one of the tasks that completed or failed in the previous run. It is not possible to retry a workflow from a task which wasn't run in the previous iteration. * `RetryFailed` - Retry the workflow that has failed. A running or waiting workflow or a workflow that completed successfully cannot be retried. Only the tasks that failed in the previous run will be retried and the rest of workflow will be run. This action does not restart the workflow and also does not support retrying from a specific task. * `RetryFromTask` - Retry the workflow that has previously reached a failed state and has the retryable property set to true. A running or waiting workflow cannot be retried. RetryFromTaskName must be passed along with this action, and the workflow will be started from that specific task. The task name in RetryFromTaskName must be one of the tasks that was executed in the previous attempt. It is not possible to retry a workflow from a task that wasn't run in the previous execution attempt. * `Cancel` - Cancel the workflow that is in running or waiting state.
		Action *string `json:"Action,omitempty"`
		// The time when the workflow info will be removed from the database. When WorkflowInfo is created, cleanup time will be set to 181 days. As the workflow progresses through different states the cleanup time can be updated. A cleanup time of 0 means the workflow is not scheduled for cleanup. An active workflow that continues to schedule & run tasks can run for any amount of time and there is no upper bound for such workflows. Workflows that are not actively running, say in Paused or Waiting states will be removed after 181 days.
		CleanupTime *time.Time `json:"CleanupTime,omitempty"`
		// The email address of the user who started this workflow. In the case of LDAP users, this field can hold either a username or an email.
		Email *string `json:"Email,omitempty"`
		// The time when the workflow reached a final state.
		EndTime *time.Time `json:"EndTime,omitempty"`
		// The duration in hours after which the workflow info for failed, terminated or timed out workflow will be removed from database. The minimum is 1 hour, maximum is 365 days and default is 90 days.
		FailedWorkflowCleanupDuration *int64 `json:"FailedWorkflowCleanupDuration,omitempty"`
		// All the given inputs for the workflow. The schema for the inputs is defined in the InputDefinition section of the WorkflowDefinition. The InputDefinition will provide a list of input fields to be accepted, the associated datatype of the inputs and any additional constraints on the inputs. For more information please refer to InputDefinition property in the the the WorkflowDefinition resource. The inputs for a workflow are provided as a collection of key-value pairs, where key is the name of the input and value is any valid JSON data which conforms to the datatype of the input as specified in the InputDefinition. When the input passed into a workflow does not match the datatype or the constraints specified in the workflow definition, it will not be accepted. For example, if the InputDefinition specified that workflow must accept a string name 'key' and the value passed for key must adhere to a regex pattern. If Workflow was started with input where 'key' is not a string matching the regex pattern, an error will be generated and workflow will not start execution. During workflow definition design, the input passed into the workflow will be referred using the format 'workflow.input.<inputName>'. If the input is referred directly in a mapping it will be in the format '${workflow.input.<inputName>}' or inside a template mapping in the format '{{.global.workflow.input.<inputName>}}'.
		Input interface{} `json:"Input,omitempty"`
		// A workflow instance Id which is the unique identified for the workflow execution.
		InstId *string `json:"InstId,omitempty"`
		// Denotes that an Intersight service started this workflow as internal and hence will not be shown in Intersight User Interface. Typically these are internal system maintenance workflows which are triggered by Intersight services.
		Internal *bool `json:"Internal,omitempty"`
		// The last action that was issued on the workflow is saved in this field. * `None` - No action is set, this is the default value for action field. * `Create` - Create a new instance of the workflow but it does not start the execution of the workflow. Use the Start action to start execution of the workflow. * `Start` - Start a new execution of the workflow. * `Pause` - Pause the workflow, this can only be issued on workflows that are in running state. A workflow can be paused for a maximum of 180 days, after 180 days the workflow will be terminated by the system. * `Resume` - Resume the workflow which was previously paused through pause action on the workflow. * `Rerun` - Rerun the workflow that has previously reached a failed state. The workflow is run from the beginning using inputs from previous execution. Completed and currently running workflows cannot be rerun. Workflows do not have to be marked for retry to use this action. * `Retry` - This action has been deprecated. Please use RetryFailed, Rerun or RetryFromTask action. Retry the workflow that has previously reached a final state and has the retryable property set to true. A running or waiting workflow cannot be retried. If the property retryFromTaskName is also passed along with this action, the workflow will be started from that specific task, otherwise the workflow will be restarted from the first task.  The task name in retryFromTaskName must be one of the tasks that completed or failed in the previous run. It is not possible to retry a workflow from a task which wasn't run in the previous iteration. * `RetryFailed` - Retry the workflow that has failed. A running or waiting workflow or a workflow that completed successfully cannot be retried. Only the tasks that failed in the previous run will be retried and the rest of workflow will be run. This action does not restart the workflow and also does not support retrying from a specific task. * `RetryFromTask` - Retry the workflow that has previously reached a failed state and has the retryable property set to true. A running or waiting workflow cannot be retried. RetryFromTaskName must be passed along with this action, and the workflow will be started from that specific task. The task name in RetryFromTaskName must be one of the tasks that was executed in the previous attempt. It is not possible to retry a workflow from a task that wasn't run in the previous execution attempt. * `Cancel` - Cancel the workflow that is in running or waiting state.
		LastAction *string           `json:"LastAction,omitempty"`
		Message    []WorkflowMessage `json:"Message,omitempty"`
		// A name of the workflow execution instance.
		Name *string `json:"Name,omitempty" validate:"regexp=^[^:]{1,92}$"`
		// All the generated outputs for the workflow. The schema for the outputs are defined in the OutputDefinition section of the WorkflowDefinition. The OutputDefinition will provide a list of output fields that could be generated after workflow execution is completed and the associated datatype of the outputs. For more information please refer to OutputDefinition property in WorkflowDefinition resource. The output for the workflow is generated as a collection of key-value pairs, where key is the name of the output and value is any valid JSON data which conforms to the datatype of output as specified in the OutputDefinition. During workflow definition design, if a workflow is included as a sub-workflow inside a parent workflow then the outputs generated by the sub-workflow can be used in the workflow design. For example, if workflow was included into parent workflow as 'SubWorkflowSample1', then that output can be referred as 'SubWorkflowSample1.output.<outputName>'. In the output is referred directly in a mapping it will be in the format '${SubWorkflowSample1.output.<outputName>}' or inside a template mapping will be in the format '{{SubWorkflowSample1.output.<outputName>}}'.
		Output interface{} `json:"Output,omitempty"`
		// Denotes the reason workflow is in paused status. * `None` - Pause reason is none, which indicates there is no reason for the pause state. * `TaskWithWarning` - Pause reason indicates the workflow is in this state due to a task that has a status as completed with warnings. * `SystemMaintenance` - Pause reason indicates the workflow is in this state based on actions of system admin for maintenance.
		PauseReason *string `json:"PauseReason,omitempty"`
		// This field indicates percentage of workflow task completion based on the total number of tasks in the workflow. The total number of tasks in the workflow is calculated based on the longest path the workflow execution can take. So progress is calculated based on the percentage of tasks that completed out of the total number of tasks that could be executed. Progress is not a representation of the time taken to complete the workflow. A task is considered as completed if the task status is either \"NO_OP\" or \"COMPLETED\". If the task status is \"SKIP_TO_FAIL\", the workflow will be terminated and the progress of the workflow will be set to 100.
		Progress   *float32                               `json:"Progress,omitempty"`
		Properties NullableWorkflowWorkflowInfoProperties `json:"Properties,omitempty"`
		// This field is required when RetryFromTask action is issued for a workflow that is in a 'final' state. The workflow will be retried from the specified task. This field must specify a task name which is the unique name of the task within the workflow. The task name must be one of the tasks that were completed or failed in the previous run. It is not possible to retry a workflow from a task that wasn't run in the previous execution attempt.
		RetryFromTaskName *string `json:"RetryFromTaskName,omitempty"`
		// The source service that started the workflow execution and hence represents the owning service for this workflow.
		Src *string `json:"Src,omitempty"`
		// The time when the workflow was started for execution.
		StartTime *time.Time `json:"StartTime,omitempty"`
		// A status of the workflow (RUNNING, WAITING, COMPLETED, TIME_OUT, FAILED). The \"status\" field has been deprecated and is now replaced with the \"workflowStatus\" field.
		// Deprecated
		Status *string `json:"Status,omitempty"`
		// The duration in hours after which the workflow info for successful workflow will be removed from database. The minimum is 1 hour, maximum is 365 days and default is 90 days.
		SuccessWorkflowCleanupDuration *int64                         `json:"SuccessWorkflowCleanupDuration,omitempty"`
		TaskInfoUpdate                 NullableWorkflowTaskInfoUpdate `json:"TaskInfoUpdate,omitempty"`
		// The trace id to keep track of workflow execution.
		TraceId *string `json:"TraceId,omitempty"`
		// A type of the workflow (serverconfig, ansible_monitoring).
		Type *string `json:"Type,omitempty"`
		// Property will be set when a user action is required on the workflow. This can be because the workflow is waiting for a wait task to be updated, workflow is paused or workflow launched by a configuration object has failed and needs to be retried in order to complete successfully.
		UserActionRequired *bool `json:"UserActionRequired,omitempty"`
		// The user identifier which indicates the user that started this workflow.
		UserId *string `json:"UserId,omitempty"`
		// All the generated variables for the workflow. During workflow execution, the variables will be updated as per the variableParameters specified after each task execution.
		Variable interface{} `json:"Variable,omitempty"`
		// Denotes the reason workflow is in waiting status. * `None` - Wait reason is none, which indicates there is no reason for the waiting state. * `GatherTasks` - Wait reason is gathering tasks, which indicates the workflow is in this state in order to gather tasks. * `Duplicate` - Wait reason is duplicate, which indicates the workflow is a duplicate of current running workflow. * `RateLimit` - Wait reason is rate limit, which indicates the workflow is rate limited by account/instance level throttling threshold. * `WaitTask` - Wait reason when there are one or more wait tasks in the workflow which are yet to receive a task status update. * `PendingRetryFailed` - Wait reason when the workflow is pending a RetryFailed action. * `WaitingToStart` - Workflow is waiting to start on workflow engine.
		WaitReason  *string                     `json:"WaitReason,omitempty"`
		WorkflowCtx NullableWorkflowWorkflowCtx `json:"WorkflowCtx,omitempty"`
		// The current state of the workflow execution instance. A draft workflow execution will be in NotStarted state and when \"Start\" action is issued then the workflow will move into Waiting state until the first task of the workflow is scheduled at which time it will move into InProgress state. When execution reaches a final state it move to either Completed, Failed or Terminated state. For more details look at the description for each state. * `NotStarted` - Initially all the workflow instances are at \"NotStarted\" state. A workflow can be drafted in this state by issuing Create action. When a workflow is in this state the inputs can be updated until the workflow is started. * `InProgress` - A workflow execution moves into \"InProgress\" state when the first task of the workflow is scheduled for execution and continues to remain in that state as long as there are tasks executing or yet to be scheduled for execution. * `Waiting` - Workflow can go to waiting state due to execution of wait task present in the workflow or the workflow has not started yet either due to duplicate workflow is running or due to workflow throttling. Once Workflow engine picks up the workflow for execution, it will move to in progress state. * `Completed` - A workflow execution moves into Completed state when the execution path of the workflow has reached the Success node in the workflow design and there are no more tasks to be executed. Completed is the final state for the workflow execution instance and no further actions are allowed on this workflow instance. * `Failed` - A workflow execution moves into a Failed state when the execution path of the workflow has reached the Failed node in the workflow design and there are no more tasks to be scheduled. A Failed node can be reached when the last executed task has failed or timed out and there are no further retries available for the task. Also as per the workflow design, the last executed task did not specify an OnFailure task to be executed and hence by default, the execution will reach the Failed node. Actions like \"Rerun\", \"RetryFailed\" and \"RetryFromTask\" can be issued on failed workflow instances. Please refer to the \"Action\" description for more details. * `Terminated` - A workflow execution moves to Terminated state when user issues a \"Cancel\" action or due to internal errors caused during workflow execution. e.g. - Task input transformation has failed. Terminated is a final state of the workflow, no further action are allowed on this workflow instance. * `Canceled` - A workflow execution moves to Canceled state when a user issues a \"Cancel\" action. Cancel is not a final state, the workflow engine will issue cancel to all the running tasks and then move the workflow to the \"Terminated\" state. * `Paused` - A workflow execution moves to Paused state when user issues a \"Pause\" action. When in paused state the current running task will complete its execution but no further tasks will be scheduled until the workflow is resumed. A paused workflow is resumed when the user issues a \"Resume\" action. Paused workflows can be canceled by user.
		WorkflowStatus   *string                                      `json:"WorkflowStatus,omitempty"`
		Account          NullableIamAccountRelationship               `json:"Account,omitempty"`
		AssociatedObject NullableMoBaseMoRelationship                 `json:"AssociatedObject,omitempty"`
		Organization     NullableOrganizationOrganizationRelationship `json:"Organization,omitempty"`
		ParentTaskInfo   NullableWorkflowTaskInfoRelationship         `json:"ParentTaskInfo,omitempty"`
		Permission       NullableIamPermissionRelationship            `json:"Permission,omitempty"`
		// An array of relationships to workflowTaskInfo resources.
		TaskInfos          []WorkflowTaskInfoRelationship                 `json:"TaskInfos,omitempty"`
		WorkflowDefinition NullableWorkflowWorkflowDefinitionRelationship `json:"WorkflowDefinition,omitempty"`
	}

	varWorkflowWorkflowInfoWithoutEmbeddedStruct := WorkflowWorkflowInfoWithoutEmbeddedStruct{}

	err = json.Unmarshal(data, &varWorkflowWorkflowInfoWithoutEmbeddedStruct)
	if err == nil {
		varWorkflowWorkflowInfo := _WorkflowWorkflowInfo{}
		varWorkflowWorkflowInfo.ClassId = varWorkflowWorkflowInfoWithoutEmbeddedStruct.ClassId
		varWorkflowWorkflowInfo.ObjectType = varWorkflowWorkflowInfoWithoutEmbeddedStruct.ObjectType
		varWorkflowWorkflowInfo.Action = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Action
		varWorkflowWorkflowInfo.CleanupTime = varWorkflowWorkflowInfoWithoutEmbeddedStruct.CleanupTime
		varWorkflowWorkflowInfo.Email = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Email
		varWorkflowWorkflowInfo.EndTime = varWorkflowWorkflowInfoWithoutEmbeddedStruct.EndTime
		varWorkflowWorkflowInfo.FailedWorkflowCleanupDuration = varWorkflowWorkflowInfoWithoutEmbeddedStruct.FailedWorkflowCleanupDuration
		varWorkflowWorkflowInfo.Input = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Input
		varWorkflowWorkflowInfo.InstId = varWorkflowWorkflowInfoWithoutEmbeddedStruct.InstId
		varWorkflowWorkflowInfo.Internal = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Internal
		varWorkflowWorkflowInfo.LastAction = varWorkflowWorkflowInfoWithoutEmbeddedStruct.LastAction
		varWorkflowWorkflowInfo.Message = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Message
		varWorkflowWorkflowInfo.Name = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Name
		varWorkflowWorkflowInfo.Output = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Output
		varWorkflowWorkflowInfo.PauseReason = varWorkflowWorkflowInfoWithoutEmbeddedStruct.PauseReason
		varWorkflowWorkflowInfo.Progress = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Progress
		varWorkflowWorkflowInfo.Properties = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Properties
		varWorkflowWorkflowInfo.RetryFromTaskName = varWorkflowWorkflowInfoWithoutEmbeddedStruct.RetryFromTaskName
		varWorkflowWorkflowInfo.Src = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Src
		varWorkflowWorkflowInfo.StartTime = varWorkflowWorkflowInfoWithoutEmbeddedStruct.StartTime
		varWorkflowWorkflowInfo.Status = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Status
		varWorkflowWorkflowInfo.SuccessWorkflowCleanupDuration = varWorkflowWorkflowInfoWithoutEmbeddedStruct.SuccessWorkflowCleanupDuration
		varWorkflowWorkflowInfo.TaskInfoUpdate = varWorkflowWorkflowInfoWithoutEmbeddedStruct.TaskInfoUpdate
		varWorkflowWorkflowInfo.TraceId = varWorkflowWorkflowInfoWithoutEmbeddedStruct.TraceId
		varWorkflowWorkflowInfo.Type = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Type
		varWorkflowWorkflowInfo.UserActionRequired = varWorkflowWorkflowInfoWithoutEmbeddedStruct.UserActionRequired
		varWorkflowWorkflowInfo.UserId = varWorkflowWorkflowInfoWithoutEmbeddedStruct.UserId
		varWorkflowWorkflowInfo.Variable = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Variable
		varWorkflowWorkflowInfo.WaitReason = varWorkflowWorkflowInfoWithoutEmbeddedStruct.WaitReason
		varWorkflowWorkflowInfo.WorkflowCtx = varWorkflowWorkflowInfoWithoutEmbeddedStruct.WorkflowCtx
		varWorkflowWorkflowInfo.WorkflowStatus = varWorkflowWorkflowInfoWithoutEmbeddedStruct.WorkflowStatus
		varWorkflowWorkflowInfo.Account = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Account
		varWorkflowWorkflowInfo.AssociatedObject = varWorkflowWorkflowInfoWithoutEmbeddedStruct.AssociatedObject
		varWorkflowWorkflowInfo.Organization = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Organization
		varWorkflowWorkflowInfo.ParentTaskInfo = varWorkflowWorkflowInfoWithoutEmbeddedStruct.ParentTaskInfo
		varWorkflowWorkflowInfo.Permission = varWorkflowWorkflowInfoWithoutEmbeddedStruct.Permission
		varWorkflowWorkflowInfo.TaskInfos = varWorkflowWorkflowInfoWithoutEmbeddedStruct.TaskInfos
		varWorkflowWorkflowInfo.WorkflowDefinition = varWorkflowWorkflowInfoWithoutEmbeddedStruct.WorkflowDefinition
		*o = WorkflowWorkflowInfo(varWorkflowWorkflowInfo)
	} else {
		return err
	}

	varWorkflowWorkflowInfo := _WorkflowWorkflowInfo{}

	err = json.Unmarshal(data, &varWorkflowWorkflowInfo)
	if err == nil {
		o.MoBaseMo = varWorkflowWorkflowInfo.MoBaseMo
	} else {
		return err
	}

	additionalProperties := make(map[string]interface{})

	if err = json.Unmarshal(data, &additionalProperties); err == nil {
		delete(additionalProperties, "ClassId")
		delete(additionalProperties, "ObjectType")
		delete(additionalProperties, "Action")
		delete(additionalProperties, "CleanupTime")
		delete(additionalProperties, "Email")
		delete(additionalProperties, "EndTime")
		delete(additionalProperties, "FailedWorkflowCleanupDuration")
		delete(additionalProperties, "Input")
		delete(additionalProperties, "InstId")
		delete(additionalProperties, "Internal")
		delete(additionalProperties, "LastAction")
		delete(additionalProperties, "Message")
		delete(additionalProperties, "Name")
		delete(additionalProperties, "Output")
		delete(additionalProperties, "PauseReason")
		delete(additionalProperties, "Progress")
		delete(additionalProperties, "Properties")
		delete(additionalProperties, "RetryFromTaskName")
		delete(additionalProperties, "Src")
		delete(additionalProperties, "StartTime")
		delete(additionalProperties, "Status")
		delete(additionalProperties, "SuccessWorkflowCleanupDuration")
		delete(additionalProperties, "TaskInfoUpdate")
		delete(additionalProperties, "TraceId")
		delete(additionalProperties, "Type")
		delete(additionalProperties, "UserActionRequired")
		delete(additionalProperties, "UserId")
		delete(additionalProperties, "Variable")
		delete(additionalProperties, "WaitReason")
		delete(additionalProperties, "WorkflowCtx")
		delete(additionalProperties, "WorkflowStatus")
		delete(additionalProperties, "Account")
		delete(additionalProperties, "AssociatedObject")
		delete(additionalProperties, "Organization")
		delete(additionalProperties, "ParentTaskInfo")
		delete(additionalProperties, "Permission")
		delete(additionalProperties, "TaskInfos")
		delete(additionalProperties, "WorkflowDefinition")

		// remove fields from embedded structs
		reflectMoBaseMo := reflect.ValueOf(o.MoBaseMo)
		for i := 0; i < reflectMoBaseMo.Type().NumField(); i++ {
			t := reflectMoBaseMo.Type().Field(i)

			if jsonTag := t.Tag.Get("json"); jsonTag != "" {
				fieldName := ""
				if commaIdx := strings.Index(jsonTag, ","); commaIdx > 0 {
					fieldName = jsonTag[:commaIdx]
				} else {
					fieldName = jsonTag
				}
				if fieldName != "AdditionalProperties" {
					delete(additionalProperties, fieldName)
				}
			}
		}

		o.AdditionalProperties = additionalProperties
	}

	return err
}

type NullableWorkflowWorkflowInfo struct {
	value *WorkflowWorkflowInfo
	isSet bool
}

func (v NullableWorkflowWorkflowInfo) Get() *WorkflowWorkflowInfo {
	return v.value
}

func (v *NullableWorkflowWorkflowInfo) Set(val *WorkflowWorkflowInfo) {
	v.value = val
	v.isSet = true
}

func (v NullableWorkflowWorkflowInfo) IsSet() bool {
	return v.isSet
}

func (v *NullableWorkflowWorkflowInfo) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableWorkflowWorkflowInfo(val *WorkflowWorkflowInfo) *NullableWorkflowWorkflowInfo {
	return &NullableWorkflowWorkflowInfo{value: val, isSet: true}
}

func (v NullableWorkflowWorkflowInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableWorkflowWorkflowInfo) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
